-- ================================
-- Fyy PREMIUM LOADER v2.0 (FIXED UNPACK ERROR)
-- ================================
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- ================================
-- CONFIGURATION
-- ================================
local BASE_URL = "http://151.240.0.25:3002"
local SECRET_ENDPOINT = "/AOJWDOJWAJDASODWAHI021031"
local VALIDATE_URL = BASE_URL .. "/validate"
local SCRIPT_URL = BASE_URL .. SECRET_ENDPOINT

-- SETTINGS
local ENABLE_LOGS = true
local MAX_RETRIES = 3
local RETRY_DELAY = 2

-- ================================
-- UTILITY FUNCTIONS
-- ================================
local function log(...)
    if ENABLE_LOGS then
        print("[Fyy Loader]", ...)
    end
end

local function safeWait(seconds)
    local start = tick()
    while tick() - start < seconds do
        RunService.Heartbeat:Wait()
    end
end

local function getHWID()
    local hwid
    local success = pcall(function()
        hwid = game:GetService("RbxAnalyticsService"):GetClientId()
    end)
    
    if success and hwid and hwid ~= "" then
        return hwid
    end
    
    pcall(function()
        hwid = game:GetService("HttpService"):GenerateGUID(false)
    end)
    
    return hwid or "HWID-" .. tostring(tick())
end

local function secureHttpGet(url)
    for attempt = 1, MAX_RETRIES do
        local success, response = pcall(function()
            return game:HttpGet(url, true)
        end)
        
        if success and response and response ~= "" then
            return response
        end
        
        if attempt < MAX_RETRIES then
            log("üîÑ Retry HTTP (" .. attempt .. "/" .. MAX_RETRIES .. ")")
            safeWait(RETRY_DELAY)
        end
    end
    return nil
end

-- ================================
-- VALIDATE KEY FUNCTION
-- ================================
local function validateKey()
    local player = Players.LocalPlayer
    if not player then 
        log("‚ùå Player not found")
        return false 
    end
    
    local USER_KEY = _G.script_key or "YOUR_KEY_HERE"
    
    if not USER_KEY or USER_KEY == "" or USER_KEY == "YOUR_KEY_HERE" then
        log("‚ùå Key tidak ditemukan")
        log("‚ÑπÔ∏è Set: _G.script_key = 'YOUR_KEY' sebelum execute loader")
        return false
    end

    local hwid = getHWID()
    local robloxId = player.UserId
    local username = player.Name
    local placeId = game.PlaceId
    
    log("üîç Validating key: " .. string.sub(USER_KEY, 1, 8) .. "...")
    
    local url = string.format(
        "%s?key=%s&hwid=%s&robloxId=%s&placeId=%s&username=%s",
        VALIDATE_URL,
        HttpService:UrlEncode(USER_KEY),
        HttpService:UrlEncode(hwid),
        tostring(robloxId),
        tostring(placeId),
        HttpService:UrlEncode(username)
    )

    local response = secureHttpGet(url)
    if not response then
        player:Kick("[Fyy Premium] ‚ùå Gagal terhubung ke server")
        return false
    end

    local data
    local success = pcall(function()
        data = HttpService:JSONDecode(response)
    end)
    
    if not success or not data then
        player:Kick("[Fyy Premium] ‚ùå Server response error")
        return false
    end

    if data.status == "ok" then
        _G.script_key = USER_KEY
        _G.fyy_hwid = hwid
        _G.fyy_userid = robloxId
        _G.fyy_username = username
        
        log("‚úÖ Validation success")
        return true, USER_KEY, hwid, robloxId, username
    else
        local errorCode = data.code or "UNKNOWN"
        local errorMsg = data.message or "Validation failed"
        
        if errorCode == "HWID_MISMATCH" then
            player:Kick("[Fyy Premium] ‚ùå Device mismatch\nHubungi admin untuk reset HWID")
        elseif errorCode == "BLACKLISTED" then
            player:Kick("[Fyy Premium] ‚ùå Key diblacklist\nHubungi owner")
        elseif errorCode == "EXPIRED" then
            player:Kick("[Fyy Premium] ‚ùå Key sudah expired")
        else
            player:Kick("[Fyy Premium] ‚ùå " .. errorMsg)
        end
        return false
    end
end

-- ================================
-- ‚úÖ FIXED: HEX TO BYTES FUNCTION
-- ================================
local function hexToBytes(hex)
    if not hex or type(hex) ~= "string" then
        log("‚ùå hexToBytes: Invalid input")
        return ""
    end
    
    local result = ""
    local temp = ""
    
    -- Process 2 characters at a time
    for i = 1, #hex, 2 do
        local byteStr = hex:sub(i, i+1)
        if #byteStr == 2 then
            local byte = tonumber(byteStr, 16)
            if byte then
                -- ‚úÖ FIX: Tidak pakai table.unpack, langsung concat
                result = result .. string.char(byte)
                temp = temp .. byteStr .. " "
            end
        end
    end
    
    if #result == 0 then
        log("‚ö†Ô∏è hexToBytes: No valid bytes converted")
        log("Hex input (first 100 chars):", hex:sub(1, 100))
    else
        log("‚úÖ hexToBytes: Converted", math.floor(#hex/2), "bytes")
    end
    
    return result
end

-- ================================
-- ‚úÖ FIXED: SIMPLE DECRYPT FUNCTION
-- ================================
local function simpleDecrypt(encryptedHex, keyHex, ivHex, tagHex)
    log("üîì Starting decryption...")
    
    -- Validate inputs
    if not encryptedHex or not keyHex then
        log("‚ùå Missing encryption data")
        return nil
    end
    
    log("Encrypted size:", #encryptedHex, "chars")
    log("Key size:", #keyHex, "chars")
    
    -- Convert hex to bytes (FIXED VERSION)
    local encrypted = hexToBytes(encryptedHex)
    local key = hexToBytes(keyHex)
    
    if #encrypted == 0 or #key == 0 then
        log("‚ùå Failed to convert hex to bytes")
        return nil
    end
    
    log("‚úÖ Bytes converted. Encrypted:", #encrypted, "bytes, Key:", #key, "bytes")
    
    -- Simple XOR decryption (for testing)
    local decrypted = ""
    local xorCount = 0
    
    for i = 1, #encrypted do
        local charCode = string.byte(encrypted, i)
        local keyIndex = ((i - 1) % #key) + 1
        local keyChar = string.byte(key, keyIndex)
        
        if charCode and keyChar then
            local decryptedChar = bit32.bxor(charCode, keyChar)
            decrypted = decrypted .. string.char(decryptedChar)
            xorCount = xorCount + 1
        end
        
        -- Progress indicator for large files
        if i % 10000 == 0 then
            log("‚è≥ Decrypting...", math.floor(i / #encrypted * 100), "%")
        end
    end
    
    log("‚úÖ XOR operations:", xorCount)
    log("‚úÖ Decrypted size:", #decrypted, "bytes")
    
    -- Check if it looks like valid Lua code
    if #decrypted > 100 and (decrypted:find("local") or decrypted:find("function")) then
        log("‚úÖ Looks like valid Lua code")
    else
        log("‚ö†Ô∏è Decrypted data doesn't look like Lua")
        log("First 200 chars:", decrypted:sub(1, 200))
    end
    
    return decrypted
end

-- ================================
-- EXTRACT DATA FROM ENCRYPTED LOADER
-- ================================
local function extractLoaderData(loaderCode)
    local data = {}
    
    data.sessionId = loaderCode:match("Session:%s*(%S+)")
    data.encryptedPayload = loaderCode:match('local ENCRYPTED_PAYLOAD = "([^"]+)"')
    data.ivHex = loaderCode:match('local IV_HEX = "([^"]+)"')
    data.tagHex = loaderCode:match('local TAG_HEX = "([^"]+)"')
    data.keyHint = loaderCode:match('local KEY_HINT = "([^"]+)"')
    
    data.isValid = data.sessionId and 
                   data.encryptedPayload and 
                   data.ivHex and 
                   data.tagHex
    
    return data
end

-- ================================
-- GET SESSION KEY FROM SERVER
-- ================================
local function getSessionKey(sessionId, userId, hwid)
    if not sessionId or not userId or not hwid then
        log("‚ùå Missing parameters for session")
        return nil
    end
    
    local sessionUrl = string.format(
        "%s/session/%s?userId=%s&hwid=%s",
        BASE_URL,
        sessionId,
        tostring(userId),
        HttpService:UrlEncode(hwid)
    )
    
    log("üîë Requesting session key...")
    
    local response = secureHttpGet(sessionUrl)
    if not response then
        log("‚ùå No response from session endpoint")
        return nil
    end
    
    local sessionData
    local success, err = pcall(function()
        sessionData = HttpService:JSONDecode(response)
    end)
    
    if not success then
        log("‚ùå Failed to parse session response:", err)
        log("Raw response:", string.sub(response, 1, 200))
        return nil
    end
    
    if sessionData.error then
        log("‚ùå Session error:", sessionData.error)
        return nil
    end
    
    if not sessionData.key then
        log("‚ùå No key in session response")
        return nil
    end
    
    log("‚úÖ Session key received")
    return sessionData.key
end

-- ================================
-- ‚úÖ FIXED: EXECUTE ENCRYPTED LOADER FUNCTION
-- ================================
local function executeEncryptedLoader(loaderCode, userId, hwid)
    log("üöÄ Starting encrypted loader execution...")
    
    -- Extract data
    local loaderData = extractLoaderData(loaderCode)
    
    if not loaderData.isValid then
        log("‚ùå Invalid loader format")
        return false
    end
    
    log("üîê Session ID:", string.sub(loaderData.sessionId, 1, 16) .. "...")
    log("üì¶ Encrypted payload size:", #loaderData.encryptedPayload, "hex chars")
    
    -- Get session key
    local sessionKey = getSessionKey(loaderData.sessionId, userId, hwid)
    if not sessionKey then
        log("‚ùå Failed to get session key")
        return false
    end
    
    log("üîë Session key received:", string.sub(sessionKey, 1, 16) .. "...")
    
    -- Try decryption
    log("üîÑ Attempting decryption...")
    local decrypted = simpleDecrypt(
        loaderData.encryptedPayload,
        sessionKey,
        loaderData.ivHex,
        loaderData.tagHex
    )
    
    if not decrypted then
        log("‚ùå Decryption failed completely")
        
        -- Fallback 1: Try to execute loader as-is
        log("üîÑ Fallback: Trying to execute loader directly...")
        local fn, err = loadstring(loaderCode)
        if fn then
            local success, err2 = pcall(fn)
            if success then
                log("‚úÖ Loader executed directly (fallback)")
                return true
            else
                log("‚ùå Direct execution failed:", err2)
            end
        else
            log("‚ùå Cannot load loader:", err)
        end
        return false
    end
    
    -- Check decrypted content
    if #decrypted < 100 then
        log("‚ö†Ô∏è Decrypted content too short:", #decrypted, "bytes")
        log("Content:", decrypted)
        
        -- Fallback 2: Still try to execute
        log("üîÑ Trying to execute anyway...")
        local fn, err = loadstring(decrypted)
        if fn then
            pcall(fn)
            log("‚úÖ Short script executed")
            return true
        end
        return false
    end
    
    -- Execute decrypted script
    log("‚úÖ Decryption successful!", #decrypted, "bytes")
    log("üìù First 100 chars:", decrypted:sub(1, 100))
    
    local fn, err = loadstring(decrypted)
    if not fn then
        log("‚ùå Failed to load decrypted script:", err)
        log("‚ö†Ô∏è Script preview (first 500 chars):")
        log(decrypted:sub(1, 500))
        return false
    end
    
    log("üöÄ Executing decrypted script...")
    local success, err = pcall(fn)
    if not success then
        log("‚ùå Script execution error:", err)
        return false
    end
    
    log("üéâ Encrypted script executed successfully!")
    return true
end

-- ================================
-- DOWNLOAD ENCRYPTED SCRIPT
-- ================================
local function downloadEncryptedScript(userKey, hwid, robloxId, username)
    if not userKey then 
        log("‚ùå No user key provided")
        return nil 
    end
    
    local url = string.format(
        "%s?key=%s&hwid=%s&robloxId=%s&username=%s",
        SCRIPT_URL,
        HttpService:UrlEncode(userKey),
        HttpService:UrlEncode(hwid),
        tostring(robloxId),
        HttpService:UrlEncode(username)
    )
    
    log("üì• Downloading from:", string.sub(url, 1, 80) .. "...")
    
    local response = secureHttpGet(url)
    if not response then
        log("‚ùå Download failed")
        return nil
    end
    
    -- Check for errors
    if response:find("ERROR:") or response:find("ACCESS DENIED") then
        local errorMsg = response:match("ERROR:%s*(.-)\n") or "Access denied"
        Players.LocalPlayer:Kick("[Fyy Premium] ‚ùå " .. errorMsg)
        return nil
    end
    
    log("‚úÖ Download successful:", #response, "bytes")
    return response
end

-- ================================
-- MAIN FUNCTION
-- ================================
local function main()
    safeWait(2)
    
    local valid, userKey, hwid, robloxId, username = validateKey()
    if not valid then
        log("‚ùå Validation failed")
        return
    end
    
    log("üë§ User:", username)
    log("üîë Key:", string.sub(userKey, 1, 8) .. "...")
    
    local loaderCode = downloadEncryptedScript(userKey, hwid, robloxId, username)
    if not loaderCode then
        return
    end
    
    -- Check what type of script we got
    if loaderCode:find("ENCRYPTED_PAYLOAD") then
        log("üîê Detected encrypted loader")
        executeEncryptedLoader(loaderCode, tostring(robloxId), hwid)
    else
        log("üìú Regular script, executing directly")
        local fn, err = loadstring(loaderCode)
        if fn then
            pcall(fn)
            log("‚úÖ Script executed")
        else
            log("‚ùå Failed:", err)
        end
    end
end

-- ================================
-- INITIALIZE
-- ================================
spawn(function()
    safeWait(3)
    
    if not _G.script_key or _G.script_key == "" then
        log("‚ÑπÔ∏è Set: _G.script_key = 'YOUR_KEY'")
        return
    end
    
    log("üöÄ Starting loader...")
    main()
end)

return {
    version = "2.3-fixed-unpack",
    description = "Fixed table.unpack error in hexToBytes"
}
